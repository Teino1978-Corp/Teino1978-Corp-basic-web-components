<!--
Aspect which maps a horizontal trackpad swipe gesture (or horizontal mouse wheel
action) to direction semantics.

@element basic-trackpad-direction
-->

<link rel="import" href="../basic-aspect/basic-aspect.html">

<script>
Polymer({

  behaviors: [Basic.Aspect],

  // Default implementations will be ovewritten with collective methods.
  goLeft: function() {},
  goRight: function() {},

  is: 'basic-trackpad-direction',

  ready: function() {
    this.addEventListener('wheel', function(event) {
      this._wheel(event.deltaX);
      event.preventDefault();
    }.bind(this));
    this._resetWheel();
  },

  // Default implementation will be overwritten with collective method.
  showTransition: function() {},

  _resetWheel: function() {
    this.position = 0;
    this._wheelDistance = 0;
    if (this._timeout) {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
  },

  _wheel: function(deltaX) {

    this._wheelDistance += deltaX;
    console.log(deltaX);

    var width = this.offsetWidth;
    var position = width > 0 ?
      this._wheelDistance / width :
      0;

    this.showTransition(false);
    this.position = Math.sign(position) * Math.min(Math.abs(position), 1);

    // TODO: After position gets to/past 1 or -1, ignore wheel events if the
    // deltaX is strictly less than the previous deltaX. This will filter out
    // the stream of fake wheel events meant to simulate decellaration.

    // TODO: Damping, or some other treatment for going past the ends.

    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeout = setTimeout(this._wheelTimedOut.bind(this), 250);
  },

  _wheelTimedOut: function() {
    console.log("timeout");
    this.showTransition(true);
    var position = this.position;
    if (position >= 0.5) {
      this.goRight();
    } else if (position <= -0.5) {
      this.goLeft();
    }
    this._resetWheel();
  }

});
</script>
