<!--
Aspect which maps a horizontal trackpad swipe gesture (or horizontal mouse wheel
action) to direction semantics.

@element basic-trackpad-direction
-->

<link rel="import" href="../basic-aspect/basic-aspect.html">

<script>
Polymer({

  behaviors: [Basic.Aspect],

  // Default implementations will be ovewritten with collective methods.
  goLeft: function() {},
  goRight: function() {},

  is: 'basic-trackpad-direction',

  ready: function() {
    this.addEventListener('wheel', function(event) {
      this._wheel(event.deltaX);
      event.preventDefault();
    }.bind(this));
    this._reset();
  },

  // Default implementation will be overwritten with collective method.
  showTransition: function() {},

  _partialResetAfterNavigation: function() {
    this.position = 0;
    this._wheelDistance = 0;
    this._absorbDeceleration = true;
  },

  _reset: function() {
    this.position = 0;
    this._wheelDistance = 0;
    this._lastDeltaX = 0;
    this._absorbDeceleration = false;
    if (this._timeout) {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
  },

  // TODO: Damping, or some other treatment for going past the ends.
  _wheel: function(deltaX) {

    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeout = setTimeout(this._wheelTimedOut.bind(this), 250);

    var acceleration = Math.sign(deltaX) * (deltaX - this._lastDeltaX);
    this._lastDeltaX = deltaX;
    console.log(deltaX + " " + acceleration + " " + this._absorbDeceleration);

    if (acceleration > 0) {
      // Aren't (or are no longer) decelerating.
      this._absorbDeceleration = false;
    } else if (this._absorbDeceleration) {
      // The wheel event was likely faked to simulate deceleration; ignore.
      return;
    }

    this._wheelDistance += deltaX;
    var width = this.offsetWidth;
    var position = width > 0 ?
      this._wheelDistance / width :
      0;

    this.showTransition(false);
    this.position = Math.sign(position) * Math.min(Math.abs(position), 1);
    if (this.position === 1) {
      console.log("goRight");
      this.goRight();
      this._partialResetAfterNavigation();
    } else if (this.position === -1) {
      console.log("goLeft");
      this.goLeft();
      this._partialResetAfterNavigation();
    }
  },

  _wheelTimedOut: function() {
    console.log("timeout");
    this.showTransition(true);
    var position = this.position;
    if (position >= 0.5) {
      console.log("snap");
      this.goRight();
    } else if (position <= -0.5) {
      console.log("snap");
      this.goLeft();
    }
    this._reset();
  }

});
</script>
